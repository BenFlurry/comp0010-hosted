"""
Module containing the cut command
"""
from io import TextIOBase
from typing import Generator, Iterator, List, Tuple, cast

from commands.base_command import BaseCommand
from commands.command_helpers import exception_handled_open, is_stream_empty
from commands.command_spec import (HELP_FLAG, AbstractCommandSpecification,
                                   CommandSpecification)
from errors.command_errors import (CommandError, UnknownFlagError,
                                   UnknownFlagValueError)
from flag import FlagSpecification, FlagValue, WildcardFlagSpecification

# With open has to be encoding agnostic


class CutCommandSpecification(AbstractCommandSpecification):
    """
    Specify a custom command specification for commands. We tell the parser to
    give us all flags verbatim, but still want the -b and -h flags.

    This command requires its own command specification, because we still want
    to preserve the functionality of the help flag, while accepting all other
    wildcards.

    While this can be abstracted to work with any other commands, only Cut
    needs it for now. When another command requires this functionality, this
    class should be generalized.
    """
    command_name = 'cut'
    flag_specifications = [
        FlagSpecification(
            "b", List[str], "Number of bytes to extract"
        ),
        HELP_FLAG,
        WildcardFlagSpecification()
    ]
    command_help_text = ('OPTIONS [FILE]',
                         'Cuts out sections from each line of a given file or '
                         'stdin and prints the line to stdout.')


class Cut(BaseCommand):
    """
    class for the cut command, which implements the BaseCommand interface
    """
    COMMAND_SPECIFICATION: CommandSpecification = CutCommandSpecification()

    def __init__(self, in_stream: TextIOBase, out_stream: TextIOBase,
                 flags: List[FlagValue], options: List[str]) -> None:
        super().__init__(in_stream, out_stream, flags, options)
        self._check_and_set_args()

    def _get_target(self) -> List[str]:
        if len(self.options) == 0:
            if is_stream_empty(self.input):
                raise CommandError("cut: no file provided and stdin is empty")
            return self.input.readlines()
        with exception_handled_open(self.options[0], 'r') as f:
            return f.readlines()

    def get_start_to_end_from_str(
            self, value: str, max_num: int) -> Tuple[int, int]:
        """
        A value can either be a string that represents a single int, an
        incomplete range (e.g. -3 or 5-) or a complete range (1-3)

        Returns:
            Tuple[int]: A tuple representing range, (start, end) - i.e. start
                        and end inclusive

        Raises:
            CommandError: If value ends up being unparsable, a command error
                          will be thrown
            UnknownFlagValueError: This happens if the flag value is empty
        """
        if len(value.strip()) == 0:
            raise UnknownFlagValueError('option requires an argument')

        splitted = value.split('-')
        if len(splitted) == 1:
            try:
                num = int(splitted[0])
                if num < 1:
                    raise CommandError('byte positions are numbered from 1')

                return (num, num)
            except ValueError as e:
                raise CommandError(f"can't convert {splitted} to int") from e
        elif len(splitted) > 2:
            raise CommandError(
                "a range should only contain maximally one '-' for ranges")
        else:
            a, b = splitted[0], splitted[1]
            try:
                if a != '' and b != '' and int(a) > int(b):
                    # this error is also thrown by the actual shell
                    raise CommandError("invalid decreasing range")

                if a != '' and int(a) < 1:
                    raise CommandError('byte positions are numbered from 1')

                return (int(a) if a != '' else 1,
                        min(int(b), max_num) if b != '' else max_num)
            except ValueError as e:
                raise CommandError(
                    f"one of the two input into cut is unknown {a}, {b}") \
                    from e

    def unionized_iterator(self,
                           values: Iterator[Tuple[int, int]]
                           ) -> Generator[Tuple[int, int], None, None]:
        """
        Consumes the input iterator and returns an iterator where each tuple
        represents a distinct range (no overlaps).

        Assumptions:
            The tuples in values should all be in the form (x, y), where x <
            y. This can be generated by get_start_to_end_from_str()

        Examples:
            [(1,3), (3,4)] -> [(1,4)]
            [(1,10), (2,9)] -> [(1,10)]
        """

        sorted_it = sorted(values)
        if len(sorted_it) == 0:
            return

        x, y = sorted_it[0]
        for next_x, next_y in sorted_it[1:]:
            if y >= next_x:
                # Extend the current interval if there's an overlap
                y = max(y, next_y)
            else:
                yield x, y
                # Yield the current interval and start a new one
                x, y = next_x, next_y
        yield x, y

    def _get_array_iterator(self, value: List[str],
                            max_num: int) -> Iterator[Tuple[int, int]]:
        """
        Parses the bytes flag value and returns an iterator going through all
        elements specified by the ranges.

        This iterator is possibly infinite; it is the responsibility of the
        caller to terminate this iterator

        Examples:
            1,2,3 -> An equivalent iterator for [1,2,3]
            1-3,5-7 -> An equivalent iterator for [1,2,3,5,6,7]
            -3,5- -> An equivalent iterator for [1,2,3,5,6,7,...]
            -2,-3 -> An equivalent iterator for [1,2,3]

        Arguments:
            value (List(str)): A list of strings that determines the range. The
                         strings should already be split into an arrays of
                         commas

            max_num (int): The maximum number that the iterator should
                           consider. This should be the file size in the
                           context of cut
        """
        return self.unionized_iterator(
            map(lambda x: self.get_start_to_end_from_str(x, max_num), value))

    def _get_max_columns(self, lines: List[str]) -> int:
        try:
            return max(len(line) for line in lines)
        except ValueError:
            # this happens when there is an empty sequence
            return 0

    def _check_and_set_args(self) -> None:
        # there is a guarantee by the parser that we'll only be able to get -b
        # so we don't have to check for that
        if len(self.flags) > 1:
            raise UnknownFlagError('only one type of list may be specified')

        if len(self.flags) < 1:
            raise UnknownFlagError(
                'you must specify a list of bytes, characters or fields')

    def run(self) -> int:
        target_lines = [
            line.rstrip('\r\n') for line in self._get_target()]

        range_iteration = self._get_array_iterator(
            cast(List[str], self.flags[0].value),
            self._get_max_columns(target_lines))

        ret_lines = [''] * len(target_lines)

        for (a, b) in range_iteration:
            for ind, _ in enumerate(ret_lines):
                ret_lines[ind] += target_lines[ind][a - 1:b]
        self.output.writelines(line + '\n' for line in ret_lines[:-1])
        if len(ret_lines) > 0:
            self.output.write(ret_lines[-1])
        return 0
