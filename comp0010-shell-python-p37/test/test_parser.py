"""
Test file defining tests to check if our grammar works.

Note carefully that the goal here is to test the _grammar_, not the parser
generated by ANTLR, because as far as we are concerned, the ANLTR parser should
be perfect.

Multiple levels of complexity for full coverage and granular issue detection.
"""


import unittest

from antlr4 import CommonTokenStream, InputStream  # type: ignore
from parameterized import parameterized

from parse.ParserGrammarLexer import ParserGrammarLexer
from parse.ParserGrammarParser import ParserGrammarParser
from parse.shell_error_listener import ShellErrorListener
from errors.parse_errors import UserParseError

# pylint: disable=line-too-long, wrong-import-position
# flake8: noqa: E501
# To support long parsed representations. Breaking it up reduces readability
# and maintainability of those strings.
# Until James fixes helper, no way to solve import position issue.


class TestParser(unittest.TestCase):
    """
    A class to test the parser. Inherits from unittest.TestCase for
    compatability with CI.
    """

    def parse_input(self, input_string: str) -> str:
        """
        Parses the input string and returns the parsed tree.

        Parameters:
        input_string (str): The input string to be parsed.

        Returns:
            str: The parsed tree as a string.
        """
        # Convert the input string to a stream
        input_stream = InputStream(input_string)

        # Tokenize the input
        lexer = ParserGrammarLexer(input_stream)
        token_stream = CommonTokenStream(lexer)

        # Parse the tokenized input
        listener = ShellErrorListener()
        parser = ParserGrammarParser(token_stream)
        parser.removeErrorListeners()
        parser.addErrorListener(listener)
        tree = parser.start()

        # Return the parsed tree
        return tree.toStringTree(recog=parser)

    @parameterized.expand([
        # Basic Tests
        ("empty command", "", "(start <EOF>)"),
        ("empty substitution", "``", "(start (commandLine (command (name (phrase (subcommand ` `))))) <EOF>)"),
        ("simple command", "pwd", "(start (commandLine (command (name (phrase pwd)))) <EOF>)"),
        ("command with args", "echo Hello World", "(start (commandLine (command (name (phrase echo))   (modifier (arg (phrase Hello)))   (modifier (arg (phrase World))))) <EOF>)"),
        ("command with quoted args", 'echo "Hello    World"', '(start (commandLine (command (name (phrase echo))   (modifier (arg (phrase (string (dq_string " (literal Hello)      (literal World) "))))))) <EOF>)'),
        ("command with flags", "ls -ac -l", "(start (commandLine (command (name (phrase ls))   (modifier (flag - (phrase ac)))   (modifier (flag - (phrase l))))) <EOF>)"),
        ("command with flags (multi-chara)", "ls -h -abcd", "(start (commandLine (command (name (phrase ls))   (modifier (flag - (phrase h)))   (modifier (flag - (phrase abcd))))) <EOF>)"),
        ("command with both flags and args", "ls -ac -l /comp0010", "(start (commandLine (command (name (phrase ls))   (modifier (flag - (phrase ac)))   (modifier (flag - (phrase l)))   (modifier (arg (phrase /comp0010))))) <EOF>)"),

        ("command with flags, args, connectors and quotes", 'ls -ac -l /comp0010 ; echo "Hello World" | cat', '(start (commandLine (sequence (command (name (phrase ls))   (modifier (flag - (phrase ac)))   (modifier (flag - (phrase l)))   (modifier (arg (phrase /comp0010))))   ;   (pipe (command (name (phrase echo))   (modifier (arg (phrase (string (dq_string " (literal Hello)   (literal World) "))))))   |   (command (name (phrase cat)))))) <EOF>)'),
        ("simple substitution", "`echo ec`ho he`llo` `echo wo``echo rld`", "(start (commandLine (command (name (phrase (subcommand ` (commandLine (command (name (phrase echo))   (modifier (arg (phrase ec))))) `) (phrase ho)))   (modifier (arg (phrase (phrase he) (subcommand ` (commandLine (command (name (phrase llo)))) `))))   (modifier (arg (phrase (subcommand ` (commandLine (command (name (phrase echo))   (modifier (arg (phrase wo))))) `) (phrase (subcommand ` (commandLine (command (name (phrase echo))   (modifier (arg (phrase rld))))) `))))))) <EOF>)"),
        ("sequence check", 'echo "1;";echo 2; echo 3', '(start (commandLine (sequence (sequence (command (name (phrase echo))   (modifier (arg (phrase (string (dq_string " (literal 1) (literal ;) ")))))) ; (command (name (phrase echo))   (modifier (arg (phrase 2))))) ;   (command (name (phrase echo))   (modifier (arg (phrase 3)))))) <EOF>)'),
        ("quotes chaining", '`echo ec`h"o" "h"`echo o`"`echo llo`"', '(start (commandLine (command (name (phrase (subcommand ` (commandLine (command (name (phrase echo))   (modifier (arg (phrase ec))))) `) (phrase (phrase h) (string (dq_string " (literal o) ")))))   (modifier (arg (phrase (phrase (phrase (string (dq_string " (literal h) "))) (subcommand ` (commandLine (command (name (phrase echo))   (modifier (arg (phrase o))))) `)) (string (dq_string " (subcommand ` (commandLine (command (name (phrase echo))   (modifier (arg (phrase llo))))) `) "))))))) <EOF>)'),
        ("double quotes in single quotes", "echo \"'Hello'\"", '(start (commandLine (command (name (phrase echo))   (modifier (arg (phrase (string (dq_string " \' (literal Hello) \' "))))))) <EOF>)'),
        ("double quotes surrounding single quotes, then option", "echo \"'\"Hello\"'\"", '(start (commandLine (command (name (phrase echo))   (modifier (arg (phrase (string (dq_string " \' ")) (phrase (phrase Hello) (string (dq_string " \' ")))))))) <EOF>)'),
        ("many single quotes in double quotes", 'echo "\'\'\'"', '(start (commandLine (command (name (phrase echo))   (modifier (arg (phrase (string (dq_string " \' \' \' "))))))) <EOF>)'),
        ("redirect with no space before", 'cat< dir1/test1.txt', "(start (commandLine (command (name (phrase cat)) (redirect <   (phrase dir1/test1.txt)))) <EOF>)"),
        ("redirect with no space after", 'cat <dir1/test1.txt', "(start (commandLine (command (name (phrase cat))   (redirect < (phrase dir1/test1.txt)))) <EOF>)"),
        ("redirect with no space both", 'cat< dir1/test1.txt', "(start (commandLine (command (name (phrase cat)) (redirect <   (phrase dir1/test1.txt)))) <EOF>)"),

        ("many single quotes in double quotes", 'echo "\'\'\'"', "(start (commandLine (command (name (phrase echo))   (modifier (arg (phrase (string (dq_string \" ' ' ' \"))))))) <EOF>)"),
        # Monster Tests
        ("monstrosity - no nested subcommands", 'echo ex``echo claim``echo ation', '(start (commandLine (command (name (phrase echo))   (modifier (arg (phrase ex (phrase ` ` (phrase echo)))))   (modifier (arg (phrase claim (phrase ` ` (phrase echo)))))   (modifier (arg (phrase ation))))) <EOF>)'),
        ("monstrosity - unholy concatenation of strings", '"ec"`echo ho` "w""o"`echo r`"`echo l`""d"', '(start (commandLine (command (name (phrase (phrase (string (dq_string " (literal ec) "))) (subcommand ` (commandLine (command (name (phrase echo))   (modifier (arg (phrase ho))))) `)))   (modifier (arg (phrase (phrase (phrase (phrase (string (dq_string " (literal w) ")) (string (dq_string " (literal o) "))) (subcommand ` (commandLine (command (name (phrase echo))   (modifier (arg (phrase r))))) `)) (string (dq_string " (subcommand ` (commandLine (command (name (phrase echo))   (modifier (arg (phrase l))))) `) "))) (string (dq_string " (literal d) "))))))) <EOF>)'),
        ("monstrosity - cmd flag, arg, option, redirects, connectors, quotes",
         "`echo hello | cat ; ls -a; echo a > temp; cat < temp -n ; cat < temp > temp2 -flag`",
         '(start (commandLine (command (name (phrase (subcommand ` (commandLine (sequence (sequence (sequence (sequence (pipe (command (name (phrase echo))   (modifier (arg (phrase hello))))   |   (command (name (phrase cat))))   ;   (command (name (phrase ls))   (modifier (flag - (phrase a))))) ;   (command (name (phrase echo))   (modifier (arg (phrase a)))   (redirect >   (phrase temp)))) ;   (command (name (phrase cat))   (redirect <   (phrase temp))   (modifier (flag - (phrase n)))))   ;   (command (name (phrase cat))   (redirect <   (phrase temp))   (redirect >   (phrase temp2))   (modifier (flag - (phrase flag)))))) `))))) <EOF>)'),
        ("monstrosity - cmd sub",
         "`echo ec`ho -spec`echo ial` he`echo llo` `echo wo`orld `echo ex``echo claim``echo ation` > `cat testing1.txt`", "(start (commandLine (command (name (phrase (subcommand ` (commandLine (command (name (phrase echo))   (modifier (arg (phrase ec))))) `) (phrase ho)))   (modifier (flag - (phrase (phrase spec) (subcommand ` (commandLine (command (name (phrase echo))   (modifier (arg (phrase ial))))) `))))   (modifier (arg (phrase (phrase he) (subcommand ` (commandLine (command (name (phrase echo))   (modifier (arg (phrase llo))))) `))))   (modifier (arg (phrase (subcommand ` (commandLine (command (name (phrase echo))   (modifier (arg (phrase wo))))) `) (phrase orld))))   (modifier (arg (phrase (subcommand ` (commandLine (command (name (phrase echo))   (modifier (arg (phrase ex))))) `) (phrase (subcommand ` (commandLine (command (name (phrase echo))   (modifier (arg (phrase claim))))) `) (phrase (subcommand ` (commandLine (command (name (phrase echo))   (modifier (arg (phrase ation))))) `))))))   (redirect >   (phrase (subcommand ` (commandLine (command (name (phrase cat))   (modifier (arg (phrase testing1.txt))))) `))))) <EOF>)")
    ])
    def test_commands(self, name: str, input_string: str, string_tree: str):
        """
        Asserts that the input_string generates a parser string tree that is
        the same as string_tree.

        Some of the above test cases are evil and meant to stretch our grammar
        to its limit.

        Parameters:
            input_string (str): The input string to be parsed
            string_tree (str): The expected string tree
        """
        self.assertEqual(
            self.parse_input(input_string),
            string_tree,
            f'{name} parameter failed'
        )

    def test_exception(self) -> None:
        """
        Tests that the parser throws an exception when it encounters an
        invalid command.
        """
        with self.assertRaises(UserParseError):
            self.parse_input("\"")


if __name__ == "__main__":
    unittest.main()
